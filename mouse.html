<!DOCTYPE HTML>
<!--
	Solid State by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Gesture Device</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Page Wrapper -->
			<div id="page-wrapper">
				<!-- Header -->
					<header id="header">
						<h1><a href="index.html">Home</a></h1>
						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

				<!-- Menu -->
					<nav id="menu">
						<div class="inner">
							<h2>Menu</h2>
							<ul class="links">
								<li><a href="index.html">Home</a></li>
								<li><a href = "https://github.com/akid12345"> Github </a></li>
								<li><a href="updates.html">CV</a></li>
								<li><a href="projects.html">Projects</a></li>
								<li><a href="rambles.html">Rambles</a></li>
							</ul>
							<a href="#" class="close">Close</a>
						</div>
					</nav>

				<!-- Wrapper -->
					<section id="wrapper">
						<header>
							<div class="inner">
								<h2>Building a Gesture Device</h2>
						</header>

						<!-- Content -->
							<div class="wrapper">
								<div class="inner">
									<h3 class="major">Purpose</h3>
									<p>For many people, elderly especially, a gesture device can be much more comfortable and intuitive to use compared to a regular mouse. Unlike a mouse, which require fine motor control, hand-eye coordination, and the ability to grip and drag small objects, gesture devices allow for much broader range of motion and more natural movement. This can help reduce strain in the wrists and fingers, which is very beneficial to elderly people with reduced motor skills. </p>
								</div>
                                <div style="display: flex; justify-content: center; align-items: center;">
									<div style="flex: 0 1 50%; text-align: center; display: flex; flex-direction: column; align-items: center;">
										<img src="images/mouse.jpg" style="width: 80%; height: auto; max-width: 100%;" alt="Silicon Plate" />
										<p>Gesture Device</p>
									</div>
								</div>
                                <pre><code>#include <Wire.h>
#include <SPI.h>
#include <BleMouse.h>

uint8_t data[6];
int16_t gyroX, gyroZ;

int Sensitivity = 200;  // Increase sensitivity to reduce cursor speed
int delayi = 5;  // Slightly increased delay for smoother movement

BleMouse bleMouse;

uint32_t timer;
uint8_t i2cData[14];

// Button states and debounce settings
bool leftButtonPressed = false;
bool rightButtonPressed = false;
bool dragging = false;

const unsigned long debounceDelay = 50;  // Debounce delay for button presses
unsigned long lastLeftDebounceTime = 0;
unsigned long lastRightDebounceTime = 0;

int lastLeftButtonState = HIGH;
int lastRightButtonState = HIGH;

const uint8_t IMUAddress = 0x68;
const uint16_t I2C_TIMEOUT = 1000;

// Thresholds for gyro movement to avoid unintended mouse movement
const int gyroThresholdX = 3; // Reduced for finer control
const int gyroThresholdZ = 3;

// Smoothing variables
float smoothedGyroX = 0;
float smoothedGyroZ = 0;
float alpha = 0.2; // Smoothing factor between 0 and 1

// Initialization delay settings
unsigned long movementStartDelay = 1000;  // 1-second delay before cursor starts moving
unsigned long startTime;
bool movementEnabled = false;

// Double-click and long press timing
unsigned long lastClickTime = 0;
const unsigned long doubleClickDelay = 400;
const unsigned long longPressDelay = 500;

uint8_t i2cWrite(uint8_t registerAddress, uint8_t* data, uint8_t length, bool sendStop) {
    Wire.beginTransmission(IMUAddress);
    Wire.write(registerAddress);
    Wire.write(data, length);
    return Wire.endTransmission(sendStop);
}

uint8_t i2cWrite2(uint8_t registerAddress, uint8_t data, bool sendStop) {
    return i2cWrite(registerAddress, &data, 1, sendStop);
}

uint8_t i2cRead(uint8_t registerAddress, uint8_t* data, uint8_t nbytes) {
    uint32_t timeOutTimer;
    Wire.beginTransmission(IMUAddress);
    Wire.write(registerAddress);
    if (Wire.endTransmission(false))
        return 1;
    Wire.requestFrom(IMUAddress, nbytes, (uint8_t)true);
    for (uint8_t i = 0; i < nbytes; i++) {
        if (Wire.available())
            data[i] = Wire.read();
        else {
            timeOutTimer = micros();
            while (((micros() - timeOutTimer) < I2C_TIMEOUT) && !Wire.available());
            if (Wire.available())
                data[i] = Wire.read();
            else
                return 2;
        }
    }
    return 0;
}

void setup() {
    Wire.begin();
    Serial.begin(115200);
    bleMouse.begin();

    // Initialize IMU settings
    i2cData[0] = 7;
    i2cData[1] = 0x00;
    i2cData[3] = 0x00;

    while (i2cWrite(0x19, i2cData, 4, false));
    while (i2cWrite2(0x6B, 0x01, true));
    while (i2cRead(0x75, i2cData, 1));
    delay(100);
    while (i2cRead(0x3B, i2cData, 6));

    // Initialize button pins for mouse clicks
    pinMode(18, INPUT_PULLUP);  // Left click
    pinMode(19, INPUT_PULLUP);  // Right click

    startTime = millis();  // Record the start time
    delay(100);
}

void loop() {
    while (i2cRead(0x3B, i2cData, 14));

    // Check if the initialization delay has passed
    if (millis() - startTime >= movementStartDelay) {
        movementEnabled = true;  // Enable movement after delay
    }

    // Read the gyro data
    gyroX = ((i2cData[8] << 8) | i2cData[9]);
    gyroZ = ((i2cData[12] << 8) | i2cData[13]);

    // Normalize gyroscope data with Sensitivity adjustment
    gyroX = gyroX / Sensitivity / 1.1 * -1;
    gyroZ = gyroZ / Sensitivity * -1;

    // Exponential smoothing
    smoothedGyroX = alpha * gyroX + (1 - alpha) * smoothedGyroX;
    smoothedGyroZ = alpha * gyroZ + (1 - alpha) * smoothedGyroZ;

    // Only process movements and clicks if BLE mouse is connected and movement is enabled
    if (bleMouse.isConnected() && movementEnabled) {
        Serial.print("Smoothed Gyro X: ");
        Serial.print(smoothedGyroX);
        Serial.print("   Smoothed Gyro Z: ");
        Serial.print(smoothedGyroZ);
        Serial.print("\r\n");

        // Non-linear scaling and move the mouse based on gyro data if above threshold
        int adjustedGyroX = (abs(smoothedGyroX) > gyroThresholdX) ? smoothedGyroX * 0.5 : smoothedGyroX;
        int adjustedGyroZ = (abs(smoothedGyroZ) > gyroThresholdZ) ? smoothedGyroZ * 0.5 : smoothedGyroZ;

        bleMouse.move(adjustedGyroZ, -adjustedGyroX);

        // Debouncing for left button (GPIO 18)
        int leftButtonState = digitalRead(18);
        unsigned long currentTime = millis();

        if (leftButtonState != lastLeftButtonState) {
            lastLeftDebounceTime = currentTime;
        }

        if ((currentTime - lastLeftDebounceTime) > debounceDelay) {
            if (leftButtonState == LOW && !leftButtonPressed) {
                // Double-click detection
                if (currentTime - lastClickTime < doubleClickDelay) {
                    bleMouse.click(MOUSE_LEFT);  // Double-click
                    Serial.println("Double-click");
                } else {
                    lastClickTime = currentTime;
                    leftButtonPressed = true;
                    Serial.println("Left Click Pressed");
                    bleMouse.press(MOUSE_LEFT);
                }
            } else if (leftButtonState == HIGH && leftButtonPressed) {
                // Long press for drag
                if (currentTime - lastClickTime >= longPressDelay && !dragging) {
                    dragging = true;
                    Serial.println("Dragging Enabled");
                } else if (!dragging) {
                    bleMouse.release(MOUSE_LEFT);
                    Serial.println("Left Click Released");
                }
                leftButtonPressed = false;
            } else if (dragging && leftButtonState == HIGH) {
                // Stop dragging when button is released
                bleMouse.release(MOUSE_LEFT);
                dragging = false;
                Serial.println("Dragging Disabled");
            }
        }
        lastLeftButtonState = leftButtonState;

        // Debouncing for right button (GPIO 19)
        int rightButtonState = digitalRead(19);
        if (rightButtonState != lastRightButtonState) {
            lastRightDebounceTime = millis();
        }

        if ((millis() - lastRightDebounceTime) > debounceDelay) {
            if (rightButtonState == LOW && !rightButtonPressed) {
                bleMouse.press(MOUSE_RIGHT);
                rightButtonPressed = true;
                Serial.println("Right Click Pressed");
            } else if (rightButtonState == HIGH && rightButtonPressed) {
                bleMouse.release(MOUSE_RIGHT);
                rightButtonPressed = false;
                Serial.println("Right Click Released");
            }
        }
        lastRightButtonState = rightButtonState;
    }

    // Delay to control the refresh rate of the loop
    delay(delayi);
}</code></pre>
							</div>
					</section>

				<!-- Footer -->
					<section id="footer">
						<div class="inner">
							<p><a href="projects.html" class="button primary small">Back</a></p>
						</div>
					</section>
                    
			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>